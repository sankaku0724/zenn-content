---
title: "【初学者向け】知っておきたい！Dockerコンテナの基本操作"
emoji: "🐋"
type: "tech"
topics:
  - "dockerdesktop"
  - "cloud"
  - "docker"
  - "container"
  - "初心者"
published: false
---

## はじめに

この記事は、以前私が書いた「[【初学者向け】DockerでWebサーバーを起動する](https://zenn.dev/joho0724/articles/sankaku0724-newcreate10)」という記事の内容を踏まえて、Dockerの基本操作についてまとめたものです。

:::message
もし誤解や間違いがあれば、ぜひコメントなどでご指摘していただけると助かります。
:::

### 私の動作環境

- Docker Desktop 4.21.1 (114176)
- Docker Engine 24.0.2
- Docker Compose v2.19.1
- MacOS Sonoma 14.4.1

## Dockerコマンド一覧

Dockerのコマンド一覧は，以下の記事に記載されています。この記事は，Docker公式ドキュメントを有志の方々が日本語に翻訳してくれているものです．

https://docs.docker.jp/engine/reference/commandline/index.html

公式による最新のドキュメントを確認したい人は，以下のリンクから飛ぶことができます．

https://docs.docker.com/

## 1.コンテナの起動から破棄までの流れ

まず，コンテナが起動するまでの流れを追っていきたいと思います．また，今回はhttpdイメージを利用します．httpdの使い方などは以下のサイトを確認してください．

https://hub.docker.com/_/httpd

私は以前，[Docker上でWebサーバーを起動した際](https://zenn.dev/joho0724/articles/sankaku0724-newcreate10)に以下のようにrunコマンドを使用しました．

```
docker run -dit --name my-apache-app -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4
```

この時に使用した`docker run`コマンドは，`docker pull`，`docker create`，`docker start`の三つのコマンドを複合した機能を持つコマンドであり，上のコマンドと下の三つのコマンドは同じ意味を持ちます．

```
docker pull httpd:2.4
docker create --name my-apache-app -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4
docker start my-apache-app
```

この三つのコマンドをそれぞれ見ていきましょう．

### docker pull

`docker pull`コマンドはイメージを取得する際に用いるものであり，

```
docker pull イメージ名orイメージID
```

といった書式で使用できます．

また，先ほどの`docker pull httpd:2.4`はhttpdの「2.4」というバージョンのイメージをダウンロードするということを表しています．

#### 最新版を意味する「latest」

ここで`docker pull httpd:2.4`を`docker pull httpd`のように[タグ名を省略した場合](https://docs.docker.jp/engine/reference/commandline/pull.html#docker-pull-an-image-from-docker-hub)，最新版を意味する「latest」というタグがつけられたとみなされ，最新のバージョンのイメージがインストールされます．

どうしても特定のバージョンを使いたい時以外は，タグを省略しても良さそうです．

### docker create

`docker create`コマンドはイメージからコンテナを作成する際に用いるものであり，

```
docker create オプション イメージ名orイメージID 実行したいコマンド
```

といった書式で使用できます．

ここで，`docker create --name my-apache-app -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4`は実行したいコマンドを省略している代わりにhttpdコンテナの制作者が定めたWebサーバーの通信をするためのコマンドが自動的に実行されます．

また，上記のコマンドでは，「**--name**」，「**-p**」，「**-v**」の三つのオプションが使用されています．

#### 「--name」オプション

「--name」オプションはコンテナ名をつける際に使用します．
先ほどのコマンドでは，`--name my-apache-app`とすることで作成したコンテナを「my-apache-app」というコンテナ名で利用できるようにしています．

#### 「-p」オプション

「-p」オプションはポート番号をマッピングする際に用いるものであり，

```
-p ホストのポート番号:コンテナのポート番号
```

といった書式で使用できます．

先ほどのコマンドでは「-p 8080:80」と指定しており，DockerホストのTCPポート8080番をコンテナの80番に結びつけています．

httpdイメージの制作者は、イメージをポート80番で待ち受け、そこからApacheに渡すように構成しています。そのため、このようにポートのマッピングを設定することで、「[http://DockerホストのIP:8080/](http://localhost:8080/)」でアクセスすると、その通信がコンテナのポート80番に転送され、Apacheが公開している内容が見えるようになります。実際に私は以前このURLにアクセスして[Webサーバーの起動を確認しました](https://zenn.dev/joho0724/articles/sankaku0724-newcreate10#3.-web%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%92%E8%B5%B7%E5%8B%95%E3%81%A0%EF%BC%81)。

Dockerでは「-p」オプションを指定しない限り、DockerホストとDockerコンテナとの通信はつながりません。Dockerホストを通じてDockerコンテナ内で動いているプログラムと通信するには、「-p」オプションの設定が必要になります．

ちなみにマッピングの状態は、`docker port`コマンドで確認できます。

#### 「-v」オプション

「-v」オプションは、コンテナの特定のディレクトリにホストのディレクトリをマウントする際に用いるものであり，

```
-v ホストのディレクトリ:コンテナのディレクトリ
```

といった書式で使用できます．

httpdコンテナの起動では、`-v "$PWD":/usr/local/apache2/htdocs/`といったように「-v」オプションを指定しており，$PWDの値をコンテナの/usr/local/apache2/htdocs/に割り当てています．

ここで，`$PWD`はdockerコマンドを入力したホスト側のカレントディレクトリを示す環境変数であり，`/usr/local/apache2/htdocs`はコンテナ側のマウント先のディレクトリです。

### docker start

`docker create`で作成したコンテナはまだ何も動作していません．

そこで`docker start`コマンドを使用することでコンテナを動かすことができます．
`docker start`コマンドは，

```
docker start コンテナ名orコンテナID
```

といった書式で使用できます．

ここまで，「**--name**」，「**-p**」，「**-v**」の三つのオプションについて説明しましたが，単一で動かすことはほとんどないと思われます．複合した機能を持つ`docker run`コマンドについての理解を深めておくと良さそうですね．

`docker start`コマンドで開始されたコンテナは`docker stop`コマンドを使用することで停止することができます．
`docker stop`コマンドは，

```
docker stop コンテナ名orコンテナID
```

といった書式で使用できます．

これで，コンテナの起動から破棄までの流れの確認は以上です．

## 2.コンテナのデタッチとアタッチ

稼働中のコンテナは何かしらのコマンドを実行しっぱなしの状態になっています．つまり，**普通であれば`docker run`した後には，他のコマンドを打てなくなる**はずです．

しかし，`docker run`を実行した後に，他のコマンド（`docker stop`など）を打ち込んで実行することが可能なのはなぜでしょうか？

それは**コンテナがバックグラウンドで動いているから**です．

コンテナをバックグラウンドで動かすための指定として「-dit」オプションというものがあります．

では，「-dit」オプションをつけずに実行するとどうなるのか試してみましょう．

```
docker run --name my-apache-app -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4
```

実行すると，次のようにログが表示され，次のコマンドを受け付けなくなります．

![](/images/sankaku12/6.png)

ここで，`Ctrl+C`を押すとコマンドを終了させることができ，次のコマンド入力を受け付けられるようになります．

`docker ps -a`で確認するとSTATUSがExitedになっていることから，コンテナが終了していることも確認できます．

![](/images/sankaku12/7.png)

このように「-dit」オプションを指定しなかった場合，コンテナをバックグラウンドで動かすことが出来ないということがわかります．
**コンテナの動作をバックグラウンドで行う必要があるなら「-dit」オプションをつけないといけない**と言うことを覚えておきましょう．

また，ここで停止したコンテナを破棄することも忘れないようにしておきましょう．

```
docker rm my-apache-app
```

「-dit」は、「-d」「-i」「-t」の3つのオプションの組み合わせです．「-d」が、端末から切り離してバックグラウンドで実行することを指定するオプションであり，「-i」と「-t」はコンテナを端末（キーボードとディスプレイ）から操作するためのオプションです。

「-d」で端末と切り離した状態で実行している状態を「**デタッチ**」と言います。逆に、先ほど「-dit」を省略して実行したときのように、端末と接続した状態で実行することを「**アタッチ**」と言います。

「-d」を指定しない時，つまりアタッチの時は端末と接続された状態なので、端末からの操作はそのままコンテナ内で実行中の既定のコマンドに流されます。デタッチの時は端末と切り離されているので、コンテナ内で実行されているコマンドに対して、何かキー操作することはできません。

また，デタッチの状態とアタッチの状態は、実行中に切り替えることができます


| デタッチへの切り替え | アタッチへの切り替え |
| ---- | ---- |
| `Ctrl+P`→`Ctrl+Q`の順に入力 | `docker attach`コマンドの入力 |

では実際に切り替えを試してみましょう．

「-d」オプションを指定せずに，「-it」のみでコンテナを実行します，

```
docker run -it --name my-apache-app -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4
```

「-d」オプションを指定していないため，コンテナはアタッチされている状態で動作します．そのため，実行画面で`Ctrl+P`，`Ctrl+Q`を入力してデタッチすると，コマンド入力できるようになりました．

![](/images/sankaku12/1.png)

`docker ps -a`で確認すると，STATUSがUpになっていることから，デタッチして端末から切り離したとしてもコンテナが実行中であることも確認できます．

![](/images/sankaku12/2.png)

次はアタッチをしてみましょう．`docker attach`コマンドは，

```
docker attach コンテナ名orコンテナID
```

といった書式で使用できます．

![](/images/sankaku12/3.png)

これにより，端末がコンテナと結びつけられます．本来はアタッチをした後にコマンド入力を受け付けるようになるのですが，httpdコンテナは例外であり，再度アタッチすることができなくなっています．

そのため，`docker ps -a`で確認するとSTATUSがExitedになっており，終了していることが確認できます．

![](/images/sankaku12/4.png)

ここで，停止したコンテナは`docker rm my-apache-app`で破棄しておきましょう．

![](/images/sankaku12/5.png)

ここで「-i」オプションと「-t」オプションの詳しい説明をします．

先ほど，アタッチしている状態で`Ctrl+P`，`Ctrl+Q`を入力してデタッチできるのはこのオプション達を指定しているからです．

「-i」オプションは入出力及びエラー出力をコンテナに対して結びつける役割を持ち，文字がコンテナに渡され、コンテナからの出力が画面に表示されるようになります。「-i」オプションを指定しないと、キー入力はコンテナに伝わらないためこうしたキー入力が効きません。そしてコンテナからの出力も届かないため、画面に各種ログが表示されることもありません。

「-t」オプションはpseudo-ttyと呼ばれる疑似端末を有効にする役割を持ちます．疑似端末は、カーソルキーやエスケープキー、Ctrlキーなどで操作するためのものです。このオプションを指定せず、「-i」オプションのみだとこれらのキーが使えず、`Ctrl+P`、`Ctrl+Q`キーが効きません。

コンテナを端末から操作する必要がないのであれば、「-i」や「-t」のオプションは必要ありません。逆に，アタッチするなどして端末から操作したい場合は、「-i」や「-t」オプションを指定する必要があります。

## 3.コンテナのメンテナンス

動作中もしくは停止中のコンテナに入り込んでファイルを確認したり編集したり、インストールしたりしたくなることがあるでしょう。ここからは、そうしたコンテナのメンテナンス方法を説明します。

コンテナに入り込んで何か操作したい時は、**「コンテナの中でシェルを実行し、そのシェルを通じてさまざまな操作をする」**という考え方があります。ここで，シェルはキーボードからの操作を読み取り、それを解釈実行して結果を画面に表示するプログラムのことを指します。`/bin/bash`などを知っているよと言う人もいるのではないでしょうか．

コンテナ内部でシェルを実行するにはコンテナが動いているかどうかによって、次のいずれかの方法を採ります。

| 停止中もしくはまだ作られていない時 | 動作中の時 |
| ---- | ---- |
| `docker run`の引数に、`/bin/sh`や`/bin/bash`などのシェルプログラムを指定し、本来実行される既定のコマンドの代わりにこれらのシェルが起動されるようにします。このときキー操作するのですから、「i」のオプションを忘れずに指定します。 | `docker exec`コマンドを使います。`docker exec -it コンテナ名 /bin/bash`のようにすると、現在コンテナ内で実行されているコマンドとは別にシェルが起動します。 |

実際に停止中のコンテナでシェルを実行してみましょう。まずは、コンテナが停止している場合から確かめます。ここでも、これまで使ってきたのと同じhttpdイメージを使います。

### 停止中のコンテナでシェルを実行する

1. /bin/bashを実行する

次のように入力して、/bin/bashを実行します。
```
docker run --name my-apache-app -it httpd:2.4 /bin/bash
```

実行すると「root@コンテナID:/usr/local/apache2#」のように表示され、このコンテナの中に入ることが出来ます。

![](/images/sankaku12/8.png)

ここで表示されている「1f8456836099」はコンテナIDです。環境によって異なります。

2. コマンドを入力する

このプロンプトで何かコマンドを入力すると、コンテナの中で実行することが出来ます。例えば，lsコマンドを実行すると，コンテナ内のファイルー覧を閲覧できます。

![](/images/sankaku12/9.png)

3. コンテナの中と外を行き来する

停止中のコンテナをメンテナンスした後に，`Ctrl+P`、`Ctrl+Q`を押してデタッチしてみましょう。

![](/images/sankaku12/10.png)

デタッチしたため、端末での操作はDockerホストに移りました。つまり、以降の操作はDockerホスト側での操作となります。この時、コンテナはまだ動いています。`docker attach`コマンドを使用すれば、コンテナに端末を再接続でき，Dockerの内部を操作できます。

![](/images/sankaku12/11.png)

このようにして，停止中のコンテナをメンテナンスすることが出来ます．

4. シェルを終了する

ここで、`exit`と入力して実行してみましょう。これは、シェル（今回の場合では，実行している「/bin/bash」のこと）を終了させることを意味します。実行すると、次のようにコンテナの外に戻ります。

![](/images/sankaku12/12.png)

5. コンテナが終了したことを確認する
Dockerでは、`docker run`（`docker create`も同様）で指定したプログラムが終了した時は、コンテナ自体が停止すると説明しました。上記の操作によって、プログラムは終了していますから、コンテナも終了しているはずです。`docker ps -a`で確認しましょう。STATUSがExitedになっており，終了していることがわかります。

![](/images/sankaku12/13.png)

6. コンテナの破棄
作業が終わったら，コンテナを削除しておきましょう。

![](/images/sankaku12/14.png)

### 実行中のコンテナでシェルを実行する

次に、動作しているコンテナに対してシェル操作する方法を説明します。言い換えると、「-d」オプションを指定してデタッチ状態で動作しているコンテナに対してシェル操作する方法です。

1. コンテナをデタッチモードで起動する

まず、次のようにhttpdコンテナを「-dit」オプションを付けて実行して起動します。

```
docker run --name my-apache-app -dit -p 8080:80 -v "$PWD"：/usr/local/apache2/htdocs/ httpd:2.4
```

2. コンテナの状態を確認する

`docker ps -a`でコンテナの状態を確認すると，STATUSがUpになっており，稼働していることがわかります。また、COMMANDを確認すると「httpd-foreground」と記述されていますが，これはhttpdイメージの製作者が設定した既定の実行コマンドであり，このコマンドがApacheを内部で起動しています。

![](/images/sankaku12/15.png)


3. シェルを起動する

では，シェルを起動してみましょう。
実行中のコンテナでシェルを起動するには`docker run`コマンドではなく，`docker exec`コマンドを用います．

```
docker exec -it my-apache-app /bin/bash
```
コマンドを実行すると，以下のようになりました。

![](/images/sankaku12/16.png)

ここでは割愛しますが，停止中のコンテナでシェルを実行した場合と同様に，各種コマンドを入力したりデタッチしたりすることももちろん可能です．

4. シェルを終了する

ここで、`exit`を入力してシェルを終了させましょう。

![](/images/sankaku12/17.png)

5. コンテナの状態を確認する

`docker ps -a`で確認すると，STATUSがUpのままであり，コンテナがまだ稼働していることがわかります。

![](/images/sankaku12/18.png)

なぜコンテナが終了していないかというと、終了したのはあくまでも`docker exec`で実行した`/bin/bash`であり、`docker run`で実行されている「httpd-foreground」が終了したわけではないからです。

6. コンテナの破棄

作業が終わったら，コンテナを削除しましょう。ここではコンテナがまだ稼働しているため，**必ずコンテナを停止した後に破棄**しましょう。

```
docker stop my-apache-app
```

```
docker rm my-apache-app
```

### `docker run`と`docker exec`の違い

このように`docker exec`を使えば、稼働中のコンテナに対して影響を与えることなく中に入り込んで作業できます。`docker run`と`docker exec`の違いはこのようになっています．

| コマンド | コンテナの状態 | シェル終了時 |
| --- | --- | --- |
| `docker run` | 停止時 | コンテナ終了 |
| `docker exec` | 稼働時 | 稼働したまま |


出来合いのコンテナを使えば、環境構築が格段と楽になります。「使いたいツールがあるけれどもインストールはちょっと」と尻込みしているツールがもしあるなら、Docker Hubで探してコンテナで利用してみてください。

こうした「1回だけ使うコンテナ」を使うとき、1つ注意点があります。それは、コンテナが増えてし

まうことです。Go言語の例では、docker runする際に、-mmオプションを指定したので、終了と同時にコンテナが破棄されました。しかし-Inオプションを指定しない場合は、それらのコンテナが残ります。その場合、docker ps-aで見ると、多数のExitedのコンテナを見ることになるでしょう。

こうならないためにも、コンテナは終了しても残ったままになることを理解し、オプションを指定する、もしくは、都度、docker rmで終了するなどして、不要になったコンテナが残らないように注意しましょう。

コラム
不要になったコンテナやイメージをすべて削除する
docker ps-aして、たくさんの終了済みコンテナが出てきたとき、それらをすべて1つずつ
docker rmすることを考えると、気が遠くなります。しかし安心してください。「docker containerprune」と入力すれば、停止しているコンテナを、すべてまとめて削除できます。安全のため、本当に削除してよいのか尋ねられるので、「y」キーを押すと、停止中のものすべてが削除されます。
$ docker container prune

イメージについても同様です。docker image pruneと入力すれば、どのコンテナも使っていないすべてのイメージを削除できます。
$ docker image prune

## さいごに

Dockerのまとめ
この章では、Dockerの基本について説明してきました。最後に、この章で学んだことをまとめておきましょう。
（1）バッグラウンドで実行するときは「-d」、キーボード操作するなら「it」
コンテナをバックグラウンドで実行するときは「-d」、キーボード操作するなら「it」を付けます。まとめて「-dit」を指定しておけばよいでしょう。

（2） ログは標準出力に表示される
ログは標準出力に表示されます。アタッチ中なら画面に表示されます。デタッチ中なら、docker
10gsで確認できます。

（3）-vでディレクトリをマウントする
コンテナは、制作者によって、「あるディレクトリにコンテンツを置く」とか「あるディレクトリを基準にコンパイルする」などが決まっています（そしてそれはドキュメントに記載されています）。そこで、♥オプションを指定して、そのディレクトリにDockerホストのディレクトリを割り当てて処理するようにします。

（4）-pでポートを設定する
コンテナは、制作者によって、どのポート番号を使うかが決まっています（そしてそれはドキュメントに記載されています）。そこで、pオプションを指定して、そのポートをDockerホストのポートに割り当てて処理するようにします。

（5） コンテナの既定のプログラムが終了したらコンテナも終了する
コンテナ内では、docker createやdocker runで指定したコマンド、もしくは、既定のコマンドが実行され、そのコマンドが終了するとコンテナも終了します。

（6）実行中のコンテナ内を操作したいときはdocker exec
コンテナ内を操作したいときは、docker execで/bin/bashなどのシェルを起動します。

（7） コンテナは既定では、終了しても削除されない終了と同時に削除したいなら、-mmオプションを指定します。
Docker操作は、ここで説明していることと、いまは説明していない環境変数の設定 （docker runのe
オプション）を理解すれば、ほぼ足ります（環境変数の話は、次の章で説明します）。
次の章では、docker runの「オプション」、すなわちマウントについて、もう少し詳しく説明します

