---
title: "【初学者向け】Dockerコンテナの基本操作"
emoji: "🐋"
type: "tech"
topics:
  - "dockerdesktop"
  - "cloud"
  - "docker"
  - "container"
  - "初心者"
published: false
---

## はじめに

この記事は、以前私が書いた「[【初学者向け】DockerでWebサーバーを起動する](https://zenn.dev/joho0724/articles/sankaku0724-newcreate10)」という記事の内容を踏まえて、Dockerの基本操作についてまとめたものです。

:::message
もし誤解や間違いがあれば、ぜひコメントなどでご指摘していただけると助かります。
:::

### 私の動作環境

- Docker Desktop 4.21.1 (114176)
- Docker Engine 24.0.2
- Docker Compose v2.19.1
- MacOS Sonoma 14.4.1

## Dockerコマンド一覧

Dockerのコマンド一覧は，以下の記事に記載されています。この記事は，Docker公式ドキュメントを有志の方々が日本語に翻訳してくれているものです．

https://docs.docker.jp/engine/reference/commandline/index.html

公式による最新のドキュメントを確認したい人は，以下のリンクから飛ぶことができます．

https://docs.docker.com/

## 1.コンテナの起動から破棄までの流れ

まず，コンテナが起動するまでの流れを追っていきたいと思います．
私は以前，[Docker上でWebサーバーを起動した際](https://zenn.dev/joho0724/articles/sankaku0724-newcreate10)に以下のようにrunコマンドを使用しました．

```
docker run -dit --name my-apache-app -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4
```

この時に使用した`docker run`コマンドは，`docker pull`，`docker create`，`docker start`の三つのコマンドを複合した機能を持つコマンドであり，上のコマンドと下の三つのコマンドは同じ意味を持ちます．

```
docker pull httpd:2.4
docker create --name my-apache-app -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4
docker start my-apache-app
```

この三つのコマンドをそれぞれ見ていきましょう．

### docker pull

`docker pull`コマンドはイメージを取得する際に用いるものであり，

```
docker pull イメージ名orイメージID
```

といった書式で使用できます．

また，先ほどの`docker pull httpd:2.4`はhttpdの「2.4」というバージョンのイメージをダウンロードするということを表しています．

#### 最新版を意味する「latest」

ここで`docker pull httpd:2.4`を`docker pull httpd`のように[タグ名を省略した場合](https://docs.docker.jp/engine/reference/commandline/pull.html#docker-pull-an-image-from-docker-hub)，最新版を意味する「latest」というタグがつけられたとみなされ，最新のバージョンのイメージがインストールされます．

どうしても特定のバージョンを使いたい時以外は，タグを省略しても良さそうです．

### docker create

`docker create`コマンドはイメージからコンテナを作成する際に用いるものであり，

```
docker create オプション イメージ名orイメージID 実行したいコマンド
```

といった書式で使用できます．

ここで，`docker create --name my-apache-app -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4`は実行したいコマンドを省略している代わりにhttpdコンテナの制作者が定めたWebサーバーの通信をするためのコマンドが自動的に実行されます．

また，上記のコマンドでは，「**--name**」，「**-p**」，「**-v**」の三つのオプションが使用されています．

#### 「--name」オプション

「--name」オプションはコンテナ名をつける際に使用します．
先ほどのコマンドでは，`--name my-apache-app`とすることで作成したコンテナを「my-apache-app」というコンテナ名で利用できるようにしています．

#### 「-p」オプション

「-p」オプションはポート番号をマッピングする際に用いるものであり，

```
-p ホストのポート番号:コンテナのポート番号
```

といった書式で使用できます．

先ほどのコマンドでは「-p 8080:80」と指定しており，DockerホストのTCPポート8080番をコンテナの80番に結びつけています．

httpdイメージの制作者は、イメージをポート80番で待ち受け、そこからApacheに渡すように構成しています。そのため、このようにポートのマッピングを設定することで、「[http://DockerホストのIP:8080/](http://localhost:8080/)」でアクセスすると、その通信がコンテナのポート80番に転送され、Apacheが公開している内容が見えるようになります。実際に私は以前このURLにアクセスして[Webサーバーの起動を確認しました](https://zenn.dev/joho0724/articles/sankaku0724-newcreate10#3.-web%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%92%E8%B5%B7%E5%8B%95%E3%81%A0%EF%BC%81)。

Dockerでは「-p」オプションを指定しない限り、DockerホストとDockerコンテナとの通信はつながりません。Dockerホストを通じてDockerコンテナ内で動いているプログラムと通信するには、「-p」オプションの設定が必要になります．

ちなみにマッピングの状態は、`docker port`コマンドで確認できます。

#### 「-v」オプション

「-v」オプションは、コンテナの特定のディレクトリにホストのディレクトリをマウントする際に用いるものであり，

```
-v ホストのディレクトリ:コンテナのディレクトリ
```

といった書式で使用できます．

httpdコンテナの起動では、`-v "$PWD":/usr/local/apache2/htdocs/`といったように「-v」オプションを指定しており，$PWDの値をコンテナの/usr/local/apache2/htdocs/に割り当てています．

ここで，`$PWD`はdockerコマンドを入力したホスト側のカレントディレクトリを示す環境変数であり，`/usr/local/apache2/htdocs`はコンテナ側のマウント先のディレクトリです。

### docker start

`docker create`で作成したコンテナはまだ何も動作していません．

そこで`docker start`コマンドを使用することでコンテナを動かすことができます．
`docker start`コマンドは，

```
docker start コンテナ名orコンテナID
```

といった書式で使用できます．

ここまで，「**--name**」，「**-p**」，「**-v**」の三つのオプションについて説明しましたが，単一で動かすことはほとんどないと思われます．複合した機能を持つ`docker run`コマンドについての理解を深めておくと良さそうですね．

`docker start`コマンドで開始されたコンテナは`docker stop`コマンドを使用することで停止することができます．
`docker stop`コマンドは，

```
docker stop コンテナ名orコンテナID
```

といった書式で使用できます．

これで，コンテナの起動から破棄までの流れの確認は以上です．

## 2.コンテナのデタッチとアタッチ

稼働中のコンテナは何かしらのコマンドを実行しっぱなしの状態になっています．つまり，**普通であれば`docker run`した後には，他のコマンドを打てなくなる**はずです．

しかし，`docker run`を実行した後に，他のコマンド（`docker stop`など）を打ち込んで実行することが可能なのはなぜでしょうか？

それは**コンテナがバックグラウンドで動いているから**です．

コンテナをバックグラウンドで動かすための指定として「-dit」オプションというものがあります．

では，「-dit」オプションをつけずに実行するとどうなるのか試してみましょう．

```
docker run --name my-apache-app -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4
```

実行すると，次のようにログが表示され，次のコマンドを受け付けなくなります．

![](/images/sankaku12/6.png)

ここで，`Ctrl+C`を押すとコマンドを終了させることができ，次のコマンド入力を受け付けられるようになります．

`docker ps -a`で確認するとSTATUSがExitedになっていることから，コンテナが終了していることも確認できます．

![](/images/sankaku12/7.png)

このように「-dit」オプションを指定しなかった場合，コンテナをバックグラウンドで動かすことが出来ないということがわかります．
**コンテナの動作をバックグラウンドで行う必要があるなら「-dit」オプションをつけないといけない**と言うことを覚えておきましょう．

ここで，停止したコンテナを破棄することも忘れないようにしておきましょう．

```
docker rm my-apache-app
```

-ditは、「-d」「-i」「-t」の3つのオプションの組み合わせです．

「-d」が、端末から切り離してバックグラウンドで実行することを指定するオプションです。

「-i」と「-t」は、このコンテナを端末（キーボードとディスプレイ）から操作するためのオプションです。

「-d」で端末と切り離した状態で実行している状態を「**デタッチ**（detach：切り離された）」と言います。逆に、先ほど「-dit」を省略して実行したときのように、端末と接続した状態で実行することを「**アタッチ**（attach：接続された）」と言います。

「-d」を指定しないとき，つまりアタッチの時は端末と接続された状態なので、端末からの操作はそのままコンテナ内で実行中の既定のコマンドに流されます。だからこそ、`Ctrl+C`を押すことで、そのコマンドが終了したのです。デタッチの時は端末と切り離されているので、コンテナ内で実行されているコマンドに対して、何かキー操作することはできません。

また，デタッチの状態とアタッチの状態は、実行中に切り替えることができます


| デタッチへの切り替え | アタッチへの切り替え |
| ---- | ---- |
| `Ctrl+P`→`Ctrl+Q`を入力 | `docker attach`コマンドの入力 |

では実際に切り替えを試してみましょう．

「-d」オプションを指定せずに，「-it」のみでコンテナを実行します，

```
docker run -it --name my-apache-app -p 8080:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4
```

実行画面で，`Ctrl+P`，`Ctrl+Q`を入力してデタッチするとコマンド入力できるようになりました．

![](/images/sankaku12/1.png)

`docker ps -a`で確認すると，STATUSがUpになっていることから，デタッチして端末から切り離したとしてもコンテナが実行中であることも確認できます．

![](/images/sankaku12/2.png)

次はアタッチをしてみましょう．`docker attach`コマンドは，

```
docker attach コンテナ名orコンテナID
```

といった書式で使用できます．

![](/images/sankaku12/3.png)

これにより，端末がコンテナと結びつけられます．本来はアタッチをした後にコマンド入力を受け付けるようになるのですが，httpdコンテナは例外であり，再度アタッチすることができなくなっています．

そのため，`docker ps -a`で確認するとSTATUSがExitedになっており，終了していることが確認できます．

![](/images/sankaku12/4.png)

ここで，停止したコンテナは`docker rm my-apache-app`で破棄しておきましょう．

![](/images/sankaku12/5.png)

ここで「-i」オプションと「-t」オプションの詳しい説明をします．

先ほど，アタッチしている状態で`Ctrl+P`，`Ctrl+Q`を入力してデタッチできるのはこのオプション達を指定しているからです．

「-i」オプションは入出力及びエラー出力をコンテナに対して結びつける役割を持ち，文字がコンテナに渡され、コンテナからの出力が画面に表示されるようになります。「-i」オプションを指定しないと、キー入力はコンテナに伝わらないためこうしたキー入力が効きません。そしてコンテナからの出力も届かないため、画面に各種ログが表示されることもありません。

「-t」オプションは

pseudo-ttyと呼ばれる疑似端末を有効にする

疑似端末は、カーソルキーやエスケープキー、［Curl］キーなどで操作するためのものです。このオプションを指定せず、プションのみだと、これらのキーが使えません。つまり、［Ctrl］+［P］、［Ctrl］+［Q］キーが効きません。
コンテナを端末から操作する必要がない（「-d」オプションを指定して、デタッチで起動したら、もう以降、何も操作しない）ということであれば、「-i」や「-t」のオプションは必要ありません。そうではなくて、あとでアタッチするなどして端末から操作したいときは、「-iや「-t」を指定する必要があります。

「-i」だけを指定するケース
docker runのオプションでは、-iと-tをセットで使うことがほとんどで、両方を合わせた-itは慣例句のごとく使われます。では、-iのみ指定するケースはあるのでしょうか？
答えは「あります」です。それは、標準入出力だけをコンテナに結びつけたいケースです。標準入出力は、「＞」「く」「Tなどの記号を使ってリダイレクトできます。例えば、何かファイルからの入力を、コンテナ上で動かすコマンドに流して実行したいときには、
$ docker run -i 実行したいコマンド イメージ名く処理したいファイル
のように、オプションだけ指定することがありえます。ファイルからの入力では、カーソルキーやエスケープキー、Ctrlキーなどは必要ないからです。を指定しないと、疑似端末を作らない分だけ
（1MB程度と言われています）、メモリーの消費を抑えることができます。

]

## 3.コンテナのメンテナンス

シェルでコンテナ操作をしたい場合に


ときには、動作中もしくは停止中のコンテナに入り込んで、ファイルを確認したり、編集したり、はたまたソフトをインストールしたいことがあります。ソフトのインストールなど大規模なものについては第8章で説明するとして、コンテナを使うだけという場合でも、「本当にコンテナ内で正しくプログラムが動いているのか」「コンテナ内のファイルの中身を知りたい」ということは、よくあります。ここでは、そうしたコンテナ内の代表的な操作の方法を説明します。

4-4-1 シェルで操作する
コンテナに入り込んで何か操作したいときは、「コンテナの中でシェルを実行し、そのシェルを通じて、さまざまな操作をする」というのが、基本的な考え方です。
memo
シェルとは、キーボードからの操作を読み取り、それを解釈実行して結果を画面に表示するプログラムです。コマンド入力のプロンプト（「#」や「$」）を表示しているのも、このプログラムです。

代表的なシェルとして、/bin/shや/bin/bashがあります。
コンテナの中でシェルを起動すれば、「$」や「＃」などのプロンプトが表示されます。ここで例えば、キーボードから「15」と入力すれば、15コマンドが実行され、ファイルー覧を確認できます。コンテナ内部でシェルを実行するには、コンテナが動いているかどうかによって、次のいずれかの方法を採ります。
memo 以下ではシェルに限って説明しますが、シェルに限らず、任意のプログラムを実行できます。

停止中もしくはまだ作られていないとき
docker runの引数に、/bin/shや/bin/bashなどのシェルプログラムを指定し、本来実行される既定のコマンドの代わりに、これらのシェルが起動されるようにします。このときキー操作するのですから、「i」のオプションを忘れずに指定します。

動作中のとき
docker execを使います。「docker exec-it コンテナ名/bin/bash」のようにすると、現在コンテナ内で実行されているコマンドとは別に、シェルが起動します。

4-4-2 停止中のコンテナでシェルを実行する実際にやってみましょう。まずは、コンテナが動いていないケースから確かめます。ここでも、これまで使ってきたのと同じ、httpdイメージを使います。
手順
停止中のコンテナでシェルを実行する
［1］
/bin/bashを実行する
次のように入力して、/bin/bashを実行します。
s docker run --name my apache-app -it httpd:2.4 /bin/bash
root@2544all64ec50:/usr/local/apache2i
実行すると、「root@コンテナ ID:/usr/local/apache2#」のようにプロンプトが表示され、このコンテナの中に入れます。
memo
/bin/bashを実行するには、コンテナの中に、そのコマンドが格納されている必要があります。
ほとんどのDockerイメージの中には/bin/bashは入っています。しかしファイルサイズを極力抑える工夫がされたDockerイメージには、1bin/bashが入っていないかもしれません。ここでの指定はシェルを実行するわけではなくて、コンテナに格納されている任意のコマンド（/bin/bash）
を実行しているのにすぎません（この説明からわかるように、例えば、/bin/passwdを指定すれば、パスワードの変更画面が表示されるというように、任意のコマンドを実行できます）。
memo
表示されている「2544a164ec50」は、コンテナIDです。環境によって異なります。
［2］任意のコマンドを入力する
このプロンプトで何か入力すれば、それは、コンテナの中で実行されます。例えば、15コマンドを実行してみましょう。コンテナの中のファイルー覧を閲覧できます。
root@2544a164ec50:/usr/local/apache2# 1s
bin
build cgi-bin
conf
error
htdoes
icons include logs modules
ほかにも、いくつかのコマンドを実行できます。必要があれば、コンテナ内のファイルを変更したり、

アプリケーションをインストールしたりすることもできます。とはいえここで、そうした操作まで行うと話が複雑になるので、それらは第8章で扱うことにし、先に進みましょう。

1［3］ コンテナの中と外を行き来する

さらに実験を続けます。先ほど、［CtrI］+［P］、［Ctr］+［Q］キーで、デタッチできると説明しました。この状態から、［Ctrl］+［P】、［Ctrl］+［Q］キーを押して、デタッチしてみましょう。すると、次のようにコマンドプロンプトが変わります。

root@2544a164ec50:/us/local/apache2# ubuntu@ip-172-31-35-228:~$

memo

172-31-35-228は、EC2インスタンスのプライベートIPアドレスです。環境によって異なります。

デタッチしたので、端末での操作はDockerホストに移りました。つまり、以降の操作は、Dockerホスト側での操作となります。このとき、コンテナはまだ動いています。docker psで確認してみましょう。

STATUSは「UP」で稼働中です。

thuntueip-172-31-35-228：~ docker ps

CONTAINER ID

IMAGE

2544a164e050

httpd:2.4

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
| COMMAND | CREATED | STATUS | PORTS | NAMES |
| "/brin/bash" | 7 houns ago | Up 7 hours | 80/top | my-apache-app |

再度、docker attachすれば、コンテナに端末を再接続できます。プロンプトが変わり、Dockerの内部を操作できます。

$ docker attach my-apache app root@2544a164c50:/us/local/apache2//

［4］ シェルを終了する

ここで、「exit」と入力してみましょう。これは、シェル（ここでは実行している「/bin/bash」のこと）を終了させることを意味します。すると、次のように、コンテナの外に戻ります。

root@2544a164c50:/us/local/apache2# exit exit
ubuntu@ip-172-31-35-228：～$
［5］ コンテナが終了したことを確認する
Dockerでは、docker run （もしくはdocker create）で指定したプログラムが終了したときは、コンテ
自体が停止状態になると説明しました。上記の操作によって、プログラムは終了していますから、コンテナも終了しているはずです。確認しましょう。STATUSが「Exited」になっていることがわかります。
ubuntu@ip-172-31-36-2288~5 decker ps -a
CONTAINER ID
IMAGE
COMMAND
CREATED
2544a1642c50
httpd:2.4
COMMAND
STATUS
"/bin/bash"
CREAIIED
PORTS
8 hours ago
STATUS
NAMES
Exited (1) 2 minutes ago
PORTSCONTAINER ID
［6］ 後始末
ひとまずの実験は終了です。いったんここで、コンテナを削除しておきましょう。
IMAGE
my apache-app
$ docker rm my-apache-app
4-4-3 実行中のコンテナでシェルを実行する
次に、実行中のコンテナに対して、シェル操作する方法を説明します。言い換えると、-dオプションを指定してデタッチ状態で動作しているコンテナに対してシェル操作する方法です。実際に操作する場合は、こちらのほうが、使うケースが多いはずです。
手順
実行中のコンテナでシェルを実行する
［1］ コンテナをデタッチモードで起動する
まずは、実験対象となる実行中のコンテナを作ります。次のようにhttpdコンテナを「-dit」オプションを付けて実行し、デタッチモードで起動します。

# docker run --name my-apache-app-dit -p 8080:80 -y "$PWD"：/usr/1ocal/apache2/htdoes/ httpd:2.4

コンテナの状態を確認する
、テナが稼働中になったことを確認します。STATUSが「Up」になって稼働しています。ここでは、MANDも確認しておきましょう。「httpd-foreground」と記述されています。これはhttpdイメージ
ご割者が設定した既定の実行コマンドです（このコマンドがApacheを内部で起動しています）。
$ docker ps
ONTAINER ID
9e6dcl c50206
IMAGE
httpd: 2.4
COMMAND
"httod-foreground"
CREATED
3 minutes ago
STATUS
Up 3 minutes
PORTS
0.0.0.0:8080-280/top
NAMES
my-apache-app
［3］ シェルを起動する
docker execコマンドで、シェルを起動してみましょう。
$ docker exec -it my-apache-app /bin/bash root@geodcic5b2d6:/us/10cal/apache2#
先ほどと同じように、プロンプトが変わり、各種コマンドを入力できます。Isコマンドを入力したりして、いくつかのコマンドを入力して試してみてください。もちろん、［Ctrl］+［P］、LCtrl」+1Q」でデタッチすることもできますが、ここでの説明は割愛します。
［4］ シェルを終了する
さて、ここで「exit」と入力してみます。するとシェルは終了します。
root@96dcle5b2d6:/us/local/apache2 exit
exit ubuntu@ip-172-31-35-228:~$
［5］ コンテナの状態を確認する
コンテナの状態を確認しましょう。STATUSはUpのままであり、稼働中であることがわかります。
$ docker ps
ONTAINER ID
9e6dc1c5b2d6
IMAGE
httpd: 2,4
COMMAND
CREATED
"httpd foreground""
3 minutes ago
STATUS
Up 3 minutes
PORTS
NAMES
0.0.0.0:8080-280/top my pace-app

なぜなら終了したのは、docker execで実行した/bin/bashであり、docker runで（暗黙的に実行されている）httpd-foregroundが終了したわけではないからです。

［6］ 後始末

ひとまずの実験は完了です。コンテナを停止し、破棄しておきましょう。

$ docker stop my-apache-app docker rm my-apache-app

4-4-4 docker runとdocker execとの違い

このようにdocker execを使えば、稼働中のコンテナに対して影響を与えることなく中に入り込んで作業できます。docker runとdocker execの違いを、図表4-10にまとめておきます。ほとんどの場合、docker execを使うことが多いはずです。

| コマンド | コンテナの状態 | シェル終了時 |
| --- | --- | --- |
| docker run | 停止時 | コンテナ終了 |
| docker exec | 稼働時 | 稼働のまま |

図表4-10 docker rundocker execとの違い

4-5 1回限り動かすコンテナの使い方

これまで使ってきたhttpdコンテナは、Webサーバー機能を提供するものであり、ずっと動かしっぱなしで利用することを前提としたものです。こうしたサーバー用途の使い方は、Dockerの代表的な活用法です。しかしそれ以外にも、Dockerの代表的な使い方があります。それは、1回限り動かすコンテナの使い方です。どういうことかというと、コンパイラや画像変換ライブラリなどの便利ツールが入っていて、そのツールを使ってDockerホストのファイルを処理したいというケースです。

4-5-1
Go言語をコンパイルする
プログラミング言語の環境を構築するのは、意外と面倒なものです。インストールが複雑なこともありますが、一度インストールしてしまうとアンインストールが困難であったり、ほかの環境に影響を与えたりすることもあるからです。その点、Dockerコンテナを使えば、手軽に試せます。コンテナを破棄してしまえば、元の状態にすぐに戻せるからです。
実際にやってみましょう。Docker Hubには、GO言語（Golang）のコンテナがあります。これを使って、Go言語のプログラムをコンパイルしてみましょう。
手順
Go言語をコンパイルする
［1］ ソースコードを用意する
Go言語のソースコードを用意します。ここでは単純に、リスト4-1に示す「hello.go」というソースコードを用意します。nanoエディタなどを起動して、このブログラムを入力してDockerホストの適当なディレクトリに保存してください。
memo
nanoエディタの使い方については、「3-4 index.htmlを作る」（p.71）を参照してください。
リスト4-1 hello.go
package main
import "fmt"
func maine) &
fmt. Printf("Hello World\n")
［2］Go言語のコンテナを起動して実行する
Go言語のイメージは、「golang」という名前です。下記のURLに使い方が記述されています。
[golang)
https://hub.docker.com/_/golang

記載されている使い方の通りに、次のコマンドを入力して実行します。このとき［1］で用意した

hello.goファイルを置いたディレクトリをカレントディレクトリにして（cdコマンドで、そのディレクトリに移動して）から、実行してください。

$ docker run --rm -v "$PWD":/usr/src/myapp -w /usr/sre/myapp golang:1.13 go build -v

イメージとして「golang:1.13」を指定しています。これは、バージョン1.13のGo言語のコンテナを示します。実行するコマンドは「go build-v」です。これはGo言語のビルドをするもので、ビルド後のバイナリが作成されます（ここで指定している-は、go buildのオプションで、画面に詳細情報を表示するという意味です）。

指定したオプションは、次の通りです。

- nm

実行が完了したとき、このコンテナを破棄するオプションです。

- v "$PWD":/usr/src/myapp

♥オプションは、すでにhttpdコンテナを使うときにも指定した、ディレクトリのマウント設定です。

ここではカレントディレクトリを、コンテナ内の/usr/src/myappに割り当てています。

- w /usr/src/myapp
- Wオプションは、コンテナ内のプログラム（すなわち、go build -v）を実行するときの作業ディレクトリを指定します。/ust/src/myappは、vオプションでマウントしたディレクトリです。これはDockerホストのカレントディレクトリにマウントされていますから、コンテナ内では、このディレクトリに対してGo言語のビルドが実行されます。

［3］

ファイルができる

ビルドが完了すると、コンテナは終了します。そして、ビルド後のプログラムがmyappという名前で生成されます。Isコマンドで確認してください。

memo

下記の結果を見るとわかりますが、myappはrootユーザーの権限で作られます。削除するには、sudo操作が必要です。

$ 1s

drwer-xr-x 6 ubuntu ubuntu

root

drwxr-xr-x 3 root

- ・・略・・・
- rw-rw r=- 1 ubuntu ubuntu
- rwxr-xr-x 1 root

root

・・・略・・・

4096 Apr 1 21:39 .

4096 Mar 15 16:44 ..

76 Apr 1 21:38 hello.go

2025490 Apr 1 21:39 myapp

［4］ 実行する

「./myapp」と入力すると実行できます。実行すると、画面には「Hello World」と表示されます。

$ ./myapp

Hello World

［5］ コンテナの状態を確認しておく

最後に、コンテナの状態を確認しておきましょう。docker ps-aと入力しても、何も表示されないことを確認してください。これは、docker runするときに、「-Im」オプションを付けているので、コマンドの実行が終わったとき（go build-vが終わったとき）に、コンテナが破棄されるためです。

$ docker ps-a

CONTAINER ID

IMAGE

CONMAND

CREATED

STATUS

PORTS

NAMES

4-5-2 コンテナがたくさん作られないように注意するここではGo言語を使う例を示しましたが、ほかにも、機械学習やTeXによる組版、PDF処理、画像変換など、さまざまな用途で、こうしたDockerコンテナが使われることがあります。オフィシャルなものは意外と少ないですが、Docker Hubを探せば、個人や団体が作っている、とても便利なコンテナがたくさん見つかります。

出来合いのコンテナを使えば、環境構築が格段と楽になります。「使いたいツールがあるけれどもインストールはちょっと」と尻込みしているツールがもしあるなら、Docker Hubで探してコンテナで利用してみてください。

こうした「1回だけ使うコンテナ」を使うとき、1つ注意点があります。それは、コンテナが増えてし

まうことです。Go言語の例では、docker runする際に、-mmオプションを指定したので、終了と同時にコンテナが破棄されました。しかし-Inオプションを指定しない場合は、それらのコンテナが残ります。その場合、docker ps-aで見ると、多数のExitedのコンテナを見ることになるでしょう。
$ docker ps -a
CONTAINER ID
65cbe975ef66
abf30c6616cf
IMAGE
golang:1.13
gollangel.13
COMMAND
"go bur id -v"
"go build -v"
CREATED
About, a minute ago
20 minutes ago
STATUS
Exited (0) About a minute ago
Exited (0) 20 minutes ago
PORTS
NAMES
adoring snyden optimistic roentgen
こうならないためにも、コンテナは終了しても残ったままになることを理解し、オプションを指定する、もしくは、都度、docker rmで終了するなどして、不要になったコンテナが残らないように注意しましょう。

コラム
不要になったコンテナやイメージをすべて削除する
docker ps-aして、たくさんの終了済みコンテナが出てきたとき、それらをすべて1つずつ
docker rmすることを考えると、気が遠くなります。しかし安心してください。「docker containerprune」と入力すれば、停止しているコンテナを、すべてまとめて削除できます。安全のため、本当に削除してよいのか尋ねられるので、「y」キーを押すと、停止中のものすべてが削除されます。
$ docker container prune

イメージについても同様です。docker image pruneと入力すれば、どのコンテナも使っていないすべてのイメージを削除できます。
$ docker image prune

4-6
Dockerのまとめ
この章では、Dockerの基本について説明してきました。最後に、この章で学んだことをまとめておきましょう。
（1）バッグラウンドで実行するときは「-d」、キーボード操作するなら「it」
コンテナをバックグラウンドで実行するときは「-d」、キーボード操作するなら「it」を付けます。まとめて「-dit」を指定しておけばよいでしょう。

（2） ログは標準出力に表示される
ログは標準出力に表示されます。アタッチ中なら画面に表示されます。デタッチ中なら、docker
10gsで確認できます。

（3）-vでディレクトリをマウントする
コンテナは、制作者によって、「あるディレクトリにコンテンツを置く」とか「あるディレクトリを基準にコンパイルする」などが決まっています（そしてそれはドキュメントに記載されています）。そこで、♥オプションを指定して、そのディレクトリにDockerホストのディレクトリを割り当てて処理するようにします。

（4）-pでポートを設定する
コンテナは、制作者によって、どのポート番号を使うかが決まっています（そしてそれはドキュメントに記載されています）。そこで、pオプションを指定して、そのポートをDockerホストのポートに割り当てて処理するようにします。

（5） コンテナの既定のプログラムが終了したらコンテナも終了する
コンテナ内では、docker createやdocker runで指定したコマンド、もしくは、既定のコマンドが実行され、そのコマンドが終了するとコンテナも終了します。

（6）実行中のコンテナ内を操作したいときはdocker exec
コンテナ内を操作したいときは、docker execで/bin/bashなどのシェルを起動します。

（7） コンテナは既定では、終了しても削除されない終了と同時に削除したいなら、-mmオプションを指定します。
Docker操作は、ここで説明していることと、いまは説明していない環境変数の設定 （docker runのe
オプション）を理解すれば、ほぼ足ります（環境変数の話は、次の章で説明します）。
次の章では、docker runの「オプション」、すなわちマウントについて、もう少し詳しく説明します